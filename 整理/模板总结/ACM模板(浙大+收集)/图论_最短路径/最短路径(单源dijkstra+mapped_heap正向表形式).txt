//单源最短路径,dijkstra算法+映射二分堆,正向表形式,复杂度O(mlogn)
//求出源s到所有点的最短路经,传入图的大小n和正向表list,buf
//返回到各点最短距离min[]和路径pre[],pre[i]记录s到i路径上i的父结点,pre[s]=-1
//可更改路权类型,但必须非负!
#define MAXN 200
#define inf 1000000000
typedef int elem_t;
struct edge_t{
    int to;
    elem_t len;
};

#define _cp(a,b) ((a)<(b))
struct heap{
    elem_t h[MAXN+1];
    int ind[MAXN+1],map[MAXN+1],n,p,c;
    void init(){n=0;}
    void ins(int i,elem_t e){
        for (p=++n;p>1&&_cp(e,h[p>>1]);h[map[ind[p]=ind[p>>1]]=p]=h[p>>1],p>>=1);
        h[map[ind[p]=i]=p]=e;
    }
    int del(int i,elem_t& e){
        i=map[i];if (i<1||i>n) return 0;
        for (e=h[p=i];p>1;h[map[ind[p]=ind[p>>1]]=p]=h[p>>1],p>>=1);
        for (c=2;c<n&&_cp(h[c+=(c<n-1&&_cp(h[c+1],h[c]))],h[n]);h[map[ind[p]=ind[c]]=p]=h[c],p=c,c<<=1);
        h[map[ind[p]=ind[n]]=p]=h[n];n--;return 1;
    }
    int delmin(int& i,elem_t& e){
        if (n<1) return 0;i=ind[1];
        for (e=h[p=1],c=2;c<n&&_cp(h[c+=(c<n-1&&_cp(h[c+1],h[c]))],h[n]);h[map[ind[p]=ind[c]]=p]=h[c],p=c,c<<=1);
        h[map[ind[p]=ind[n]]=p]=h[n];n--;return 1;
    }
};

void dijkstra(int n,int* list,edge_t* buf,int s,elem_t* min,int* pre){
    heap h;elem_t e;
    int v[MAXN],i,t;
    for (h.init(),i=0;i<n;i++)
        min[i]=((i==s)?0:inf),v[i]=0,pre[i]=-1,h.ins(i,min[i]);
    while (h.delmin(i,e))
        for (v[i]=1,t=list[i];t<list[i+1];t++)
            if (!v[buf[t].to]&&min[i]+buf[t].len<min[buf[t].to])
                pre[buf[t].to]=i,h.del(buf[t].to,e),min[buf[t].to]=e=min[i]+buf[t].len,h.ins(buf[t].to,e);
}