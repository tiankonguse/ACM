# C 最小生成树

给定一张连通图，该图有 n 个点以及 m 条带有边权的无向边，且 n 个点中有 k 个点是特殊的。求该图的一棵生成树满足

所有特殊点都是该生成树的叶子，并且
生成树中边权的总和最小。
请回忆：生成树是原图的连通子图，该连通子图含有 n 个点以及 (n−1) 条边。另外，叶子指的是树上恰有一条边与其相连的点。

输入格式
有多组测试数据。第一行输入一个整数 T 代表测试数据组数。对于每组测试数据：

第一行输入两个整数 n 和 m（2≤n≤10^5  ，n−1≤m≤10^5 ）表示图的点数和边数。

对于接下来的 m 行，第 i 行输入三个整数 u i​ ，v i​  和 w i​ （1≤u i​ ,v i​ ≤n，1≤w i​ ≤10^9 ）表示有一条权为 w i​  的边连接点 u i​  和 v i​ 。保证输入的图是连通的，但可能有自环或重边。

下一行输入一个整数 k（1≤k≤n）表示特殊点的数量。

再下一行输入 k 个整数 a 1​ ,a 2​ ,⋯,a k​ （1≤a i​ ≤n）表示特殊点。

保证所有数据 n 之和以及 m 之和不超过 10^6 。

输出格式
每组数据输出一行，若存在符合要求的生成树则输出生成树的最小边权总和，否则输出 "Impossible"（不输出引号）。

样例输入
2
5 7
1 2 1
1 3 3
4 1 1
2 4 3
4 3 1
3 5 1
5 4 5
2
5 3
5 5
1 2 1
3 4 1
1 3 1
4 2 1
5 4 1
3
4 2 5
样例输出
8
Impossible
样例解释
下图展示了第一组样例数据，其中实线表示最优生成树中的边，虚线表示原图中的其它边。