# J. 区间染色


## 题意

给 n 个数字，每个数字有一个颜色。  
每次最长可以将连续 k 个数字染成相同的颜色。  
问最少通过多少次染色可以将 n 个数字染成相同的颜色。  
条件：


## 原题 颜色个数在 100 以内

思路：枚举每一个颜色。  
循环找到下个非当前颜色的位置 p ，染色一次，然后从 p+k 从新开始寻找下个非当前颜色。  

复杂度：`O(100*n)`  


## 扩展1：颜色的数值在 `10e19` 范围内  


思路：预处理每个颜色，储存每个颜色的下标列表 `map<ll, set<int>>`。  
然后枚举每个颜色，计算需要颜色的个数。  

例如颜色 c 的有一个相邻的颜色 `a,b`，恰好染色到 a，则接下来可以颜色的个数是 `(b-a-1)/k`。  
如果不能整除，则需要多染色一个，且 b 会被重复染色，超过的边界是 `b + (k - (b-a-1)%k - 1)`。  

解释：
`(b-a-1)%k` 代表 b 前面需要颜色的格式  
`k - (b-a-1)%k - 1` 代表 b 之后需要颜色的个数。  
`b + (k - (b-a-1)%k - 1)` 就是 b 之后颜色的边界。  


复杂度：`O(n)`  
复杂度解释：虽然是枚举每个颜色，但是每个颜色只会循环颜色的个数次。 所有次数之和恰好等于 `n`


## 扩展2：要求染色后颜色最大值与最小值差值不大于 `b`，且颜色个数 a 不大于 k


思路：首先可以证明，最优值得颜色的最小值与最大值都是输入的颜色。  

证明：假设最优值得某个颜色区间是 `[low, hight]`。  
如果 `low` 不是输入的颜色，`low+x` 是大于 `low` 的第一个颜色。  
那染色为 `low` 的区间都可以染色为 `low+x` 答案不会更差，甚至可能会更优。  
因此，最优值对应的最小值颜色是输入的颜色没问题。  


次后，枚举每个颜色 `low`，可以得到一个合法区间`[low, low+b]`。  
我们需要找到下一个需要染色的起始位置 l，然后将 `[l, l+k-1]` 区间染色。  
再之后，我们需要找到 `l+k+1` 之后下一个需要颜色的起始位置。  

最坏情况下，区间各一个元素就需要染色，不考虑查找下一个位置的时间，复杂度是`O(a * (n/k)) < O(n)` 


那如何找到下一个需要染色的起始位置呢？  
我们需要先明确需要起始位置的特征，即值不在`[low, low+b]` 颜色范围内的第一个颜色。  
这个可以通过二分判断区间是否都满足来找到左边界。  
如果一个区间合法，意味着区间的最小值与最大值都在 `[low, low+b]` 内，可以通过线段树 `log(n)` 得到。 

由此，就可以通过二分加线段树找到下个位置。  


综合复杂度：`O(a * (n/k) * log(n)* log(n)) <  < O(n)* log(n)* log(n)`









