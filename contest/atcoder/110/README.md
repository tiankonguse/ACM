# AtCoder Regular Contest 110

## A	Redundant Redundancy

题意：输入一个数字 x，求一个数字 y，要求`[1, x]`的数字除 y 都剩余 1。  
要求 y 的范围不超过 `10^13`。  


思路：如果对 y 没有要求，`x! +1` 就是一个答案。  
这里对范围有要求，我们就要进行化简，求出最小的值。  


假设 x 为 6， `2*3*4*5*6 = 720`。  
对于素数 2， 对应的数字有 `2 4 6`，这些数字的 2 只需要乘一次就行了。  
对于素数 3，也是一样的道理。  


这个总结一下，就是每个素数指保留幂数最大的次数，其他的忽略。  


## B - Many 110

题意：字符串 `110` 重复了 `10^10`次组成字符串 S。问输入的字符串在 S 中存在多少子串。  


思路：先预先判断输入的字符串是否符号 `110` 的模式，大概有下面几种情况。


```
0
1
11
10
01
11*
10*
01*
```

对于长度只有一个的和只有两个的，可以直接计算出来。  
而对于大于等于 3 个的，需要根据前缀来列出方程，计算出公式。  


对于前缀`11`，可以不断的右移 3 位得到相同的子串。 所以个数是 `1 + (L - n)/3`  
对于前缀`10`，也可以不断的左移 3 位，但是由于前面浪费了一个字符，所以需要减去1。个数为`1 + (L - 1 - n)/3`
同理，前缀`01` 前面浪费了两个字符，需要减去 2，个数为 `1 + (L - 2 - n)/3`。



## C - Exoswap

题意：给一个数列，相邻的数字只能交换一次，问是否可以使数列升序。  


思路：贪心即可。  


从后向前扫描，找到第一个不等于自己的数字 b 。  
这个数字肯定在前面，假设在位置 a。  
此时，b 数字必须从 位置a 不断向后交换至 位置b 才行。  


如果过程中发现位置已经交换过了，则直接是不可行的。  
斗则最终就可以将所有数字排序为升序。  


## D - Binomial Coefficient is Fun  
















